# Categorical programming (updated)

## Quivers

First, we have syntax for quivers, and morphisms of quivers.

A quiver is specifies by a comma-separated list of symbols. A symbol on its own
(e.g. `a`) is the name of an object. A symbol followed by a signature between
symbols is the name of an arrow (e.g. `f : a -> b`)

You can surround by parentheses when needed.

So for example, we can define the category generated by a single object and a single morphism:
```
Loop := FreeCat(a, e : a -> a)
```

A quiver-morphism written using the same notation, but with `=` to specify what something maps to.

So for example given the two definitions:
```
Loop := FreeCat(a, e : a -> a)

Twice := FreeCat(b, out : b -> b)
```

We can define a functor `Twice -> Loop` with:

```
FromFreeCat(a = b, out : b -> b = e e)
```

The system will infer as much as possible:

- We don't need the `b -> b` part of `out : b -> b`, since this is known from
  `Twice := FreeCat(b, out : b -> b)`:
  ```
  FromFreeCat(a = b, out = e e)
  ```
- We don't need `a = b` even, since `e e` is inferred to be `a -> a`, and so
  `out = e e` forces `a = b`:
  ```
  FromFreeCat(out = e e)
  ```
- We _might_ take by default that a quiver in the position of a functor
  `FreeCat(..) -> ...` will be a use of `FromFreeCat`, and so even just write
  this:
  ```
  (out = e e)
  ```

## Limits and Colimits

Limits and colimits are defined using quivers too. If we want to define a sub of two objects `A` and `B`, we can use the quiver:
```
(a, b)
```
(This quiver has no arrows.)

To define the colimit, we define a functor into our target category:

```
(a = A, b = B)
```
(Again the `FromFreeCat` can be suppressed.)

So in total:

```
EitherAorB := Colimi(a = A, b = B)
```

If we use `[..]` instead of `(..)`, this is an implicit call to `Colim`:

```
EitherAorB := [a = A, b = B]
```

Morphisms from a colimit are specified via a cocone, that is, a natural
transformation to the constant functor of the object you are mapping to. A
natural transformation is also written using the syntax using `=`, so for example:

```
[ a = + 1, b = + 2 ]
```

is a morphism `[ a = Int, b = Int ] -> Int`.

**NOTE:** This quiver only has objects, so it's quite simple. If your quiver has
arrows, then you need to provide some _proofs_ in the arrow components.

## Recursive definitions

What about defining natural numbers?

We augment from quivers to sketches. this means we can for example refer to
products. We define a sketch for natural numbers equipped with addition:

```
NatSketch = (nat, plus : {x: nat, y: nat} -> nat)
```

And then we define an endomorphism of `FreeCat(NatSketch)`:

```
NatDef :=
(
  nat = [ zero = {}, succ = nat ],
  plus = @x [ zero = .y,
              succ = { x = .x, y = .y } plus succ. ]
)
```

We'll call a sketch equipped with an endomorphism a _recursive sketch_.

**NOTE:** If the sketch you have has diagrams, then your endomorphism also needs
to supply some proofs.

**NOTE:** There is a lot of detail to be worked out. For example, the notion of
"free category" here requires coproducts.

If your sketch has property _TODO_, and your category `C` has property _TODO_,
then recursive sketches can be _realised_. This means that you can find a
functor:

```
Nat : FreeCat(NatSketch) -> C
```

such that the equality (equivalence?) of functors:
```
NatDef Nat = Nat
```
holds. Then `Nat(nat)` is an object of `C`, and `Nat(plus)` is a morphism of
`C`, and any property you prove of the recursive sketch will hold for these in
`C`.

## Macros

Let's go back to the question of macros, for example, how to define a "macro" for composing a morphism with itself.

Going back to the defintion of `Loop` and `Twice`, and the functor between them:

```
twice : Twice -> Loop
twice := (out = e e) 
```

So if we are programming in some category `C`, that is, defining morphisms in `C`, and we want to use this macro, then we start by defining a functor `Loop -> C`:

```
useMacro : Loop -> C
useMacro := (e = plus1)
```

We then use composition of functors to use the macro: `twice (e = plus1)` is now a
functor `Twice -> C`. We can apply that functor to the morphism `out` of `Twice`
to get a morphism in `C`: `(twice (e = plus1))(out)`.

We use a convention that if the source category has a morphism called `out`,
then using `#` is a shorthand to applying the functor to `out`.

Example:
```
foo : { x : Int, y : Int } -> { x : Int, y : Int }
foo :=
  { x = .x plus1,
    y = .y #(twice (e = plus1)) }
```

This takes a pair of numbers, incrementing the `x`-component, and adding `2` to
the `y`-component.


---

About the definition of `map`:

- We can define a functor for lists directly. More on this later.
- But we should also be able to define it "directly", as other higher-order list functions.

It is done, roughly, like this:

```
map : (C[f] -> C) -> (C[f] -> C) 
```

The point is that, one defines, for some category `C` for which one has already defined a list object, this thing `map` above.

We then use the fact that `C[f] -> C` has _some property_ which ensures that
this recursion works outs, so that we can just get `C[f] -> C`. We can then, for
any `f`, use this to get an arrow in `C`.


